---
title: "Data analysis pilot study: test framing and bioinspired items"
author: "Julius Fenn, Stephanie Bugler"
format:
  html:
    toc: true
    toc-depth: 3
    html-math-method: katex
    number-sections: true
---


# Notes


# global variables

Define your global variables (can take some time to run):

```{r}
#| label: global variables

runIRTmodels <- FALSE


## global variables
runMplusLCA <- FALSE
## set to lower values to reduce compilation time: 
nRep_def = 100 # 100
n.lambda_def = 40 # 40
LCArunsDef = 8 # 10
```




# load raw data


```{r}
#| label: create raw files
#| warning: false

# sets the directory of location of this script as the current directory
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))

### load packages
require(pacman)
p_load('tidyverse', 'jsonlite',
       'stargazer',  'DT', 'psych',
       'writexl', 'moments', 'lavaan', 'semPlot', 'mirt', 'MplusAutomation',
       'afex', 'emmeans', 'jtools',
       'car')


setwd("../01_dataPreperation/outputs")
dat <- read_rds(file = "questionnaire.rds")


### load functions
setwd("../../../functions")
for(i in 1:length(dir())){
  # print(dir()[i])
  source(dir()[i], encoding = "utf-8")
}

rm(i)


### summary function
data_summary <- function(data, varname, groupnames){
  require(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      se = sd(x[[col]], na.rm=TRUE) / sqrt(length(x[[col]])))
  }
  data_sum<-ddply(data, groupnames, .fun=summary_func,
                  varname)
  data_sum <- plyr::rename(data_sum, c("mean" = varname))
  return(data_sum)
}
```
# Remove persons how participants two times

```{r}
tmp <- names(table(dat$PROLIFIC_PID))[table(dat$PROLIFIC_PID) >= 2]
tmp; length(tmp)

dat[dat$PROLIFIC_PID %in% tmp[1],]

## keep only first participation
keep_rows <- do.call(rbind, lapply(tmp, function(id) {
  rows <- dat[dat$PROLIFIC_PID == id, ]
  rows[which.min(as.numeric(rownames(rows))), , drop = FALSE]
}))



nrow(dat)
dat <- dat[!dat$PROLIFIC_PID %in% tmp, ]
dat <- rbind(dat, keep_rows)
nrow(dat)
```




# Descriptive Statistics


To describe sample:

```{r}
psych::describe(dat[, c("sociodemo_age")])
table(dat$sociodemo_gender)
table(dat$sociodemo_gender) / nrow(dat)
prop.table(table(dat$sociodemo_gender))

table(dat$sociodemo_priorExperience)
table(dat$sociodemo_priorExperience) / nrow(dat)

table(dat$socio_sex) # from Prolific
table(dat$socio_sex, dat$sociodemo_gender)

table(dat$socio_employment)
table(dat$socio_ethnicity)

```
To describe study conditions:

```{r}
table(dat$framingCondition)
```




To describe length of study:

```{r}
psych::describe(dat[, c("total_min_prolific")])
hist(dat$total_min_prolific)
abline(v = mean(dat$total_min_prolific))
```

To describe conditions:

```{r}
table(dat$framingCondition, dat$whichItemsFirst)
```

## Check for differences between conditions

```{r}
## -----------------------------
## Descriptive statistics
## -----------------------------

# Age
mean(dat$sociodemo_age, na.rm = TRUE)
sd(dat$sociodemo_age, na.rm = TRUE)
summary(dat$sociodemo_age)   # includes median

# Gender counts + proportions
table(dat$sociodemo_gender)
prop.table(table(dat$sociodemo_gender))

# Prior experience counts + proportions
table(dat$sociodemo_priorExperience)
prop.table(table(dat$sociodemo_priorExperience))


## -----------------------------
## Check for differences between framing conditions
## -----------------------------
# 1. Age differences across conditions (ANOVA)
anova_age <- aov(sociodemo_age ~ framingCondition, data = dat)
summary(anova_age)

# Also check assumptions
shapiro.test(residuals(anova_age))
car::leveneTest(sociodemo_age ~ framingCondition, data = dat)  # requires car package

# 2. Gender differences across conditions (Chi-square)
gender_table <- table(dat$framingCondition, dat$sociodemo_gender)
chisq.test(gender_table)

# 3. Prior experience differences across conditions (Chi-square)
experience_table <- table(dat$framingCondition, dat$sociodemo_priorExperience)
chisq.test(experience_table)

```

## remove participants with insufficient effort responding (IER)

insufficient effort responding: respondents provide careless or random responses to survey items

### IER: set up dataset


```{r IER_dataset}
dat_IER <- data.frame(PROLIFIC_PID = dat$PROLIFIC_PID)


#### slow persons total duration
dat_IER$slowTD <- 0

out <- boxplot.stats(dat$total_min_prolific)$out
out_ind <- which(dat$total_min_prolific %in% c(out))

dat_IER$slowTD[dat_IER$PROLIFIC_PID %in% dat$PROLIFIC_PID[out_ind]] <- 1


#### careless respondents based on
# > intra-individual response variability
# > zero SD (all answers equal)
# > Mahalanobis distance (multivariate outliers)
# > compute SD over rows

rowVars <- function(x, na.rm=FALSE) {
  # Vectorised version of variance filter
  rowSums((x - rowMeans(x, na.rm=na.rm))^2, na.rm=na.rm) / (ncol(x) - 1)
}


scales_regEX <- c("^EcologicalDimension",
            "Bioinspiration.*PN",
             "Bioinspiration.*VRtN",
             "Bioinspiration.*IPI")


mat_IIRV <- matrix(data = 0, nrow = nrow(dat), ncol = length(scales_regEX)+1)
mat_IIRV[,1] <- dat$PROLIFIC_PID

mat_zero <- matrix(data = 0, nrow = nrow(dat), ncol = length(scales_regEX)+1)
mat_zero[,1] <- dat$PROLIFIC_PID

mat_MD <- matrix(data = 0, nrow = nrow(dat), ncol = length(scales_regEX)+1)
mat_MD[,1] <- dat$PROLIFIC_PID


h = 2
for(e in scales_regEX){
  tmp <- dat[, str_subset(string = colnames(dat), pattern = e)]
  tmp <- tmp[, str_subset(string = colnames(tmp), pattern = "^mean_", negate = TRUE)]

  ## by intra-individual response variability
  tmp_SD <- sqrt(rowVars(tmp))
  out <- boxplot.stats(tmp_SD)$out
  mat_IIRV[,h][mat_IIRV[,1] %in% dat$PROLIFIC_PID[tmp_SD %in% out]] <- 1

  ## zero SD (all answers equal)
  mat_zero[,h][mat_zero[,1] %in% dat$PROLIFIC_PID[tmp_SD == 0]] <- 1



  ## by Mahalanobis distance (multivariate outliers)
  tmp$mahal <- mahalanobis(tmp, colMeans(tmp), cov(tmp))
  tmp$p_mahal <- pchisq(tmp$mahal, df=ncol(tmp)-2, lower.tail=FALSE)
  mat_MD[,h][mat_MD[,1] %in% dat$PROLIFIC_PID[tmp$p_mahal %in% tmp$p_mahal[tmp$p_mahal < .001]]] <- 1


 h = h + 1
}


labels <- str_replace_all(string = scales_regEX, pattern = "\\W+", replacement = "")

dat_IIRV <- as.data.frame(mat_IIRV)
colnames(dat_IIRV) <- c("PROLIFIC_PID",
                        labels)
dat_zero <- as.data.frame(mat_zero)
colnames(dat_zero) <- c("PROLIFIC_PID",
                        labels)
dat_MD <- as.data.frame(mat_MD)
colnames(dat_MD) <- c("PROLIFIC_PID",
                      labels)



dat_IIRV[,labels] <- lapply(dat_IIRV[,labels], as.numeric)
dat_zero[,labels] <- lapply(dat_zero[,labels], as.numeric)
dat_MD[,labels] <- lapply(dat_MD[,labels], as.numeric)


## ADD by intra-individual response variability
table(rowSums(dat_IIRV[,labels]))
tmp <- rowSums(dat_IIRV[,labels]) >= 3
dat_IER$IIRV <- 0
dat_IER$IIRV[dat_IER$PROLIFIC_PID %in% dat_IIRV$PROLIFIC_PID[tmp]] <- 1

## ADD zero SD (all answers equal)
table(rowSums(dat_zero[,labels]))
tmp <- rowSums(dat_zero[,labels]) >= 3
dat_IER$zero <- 0
dat_IER$zero[dat_IER$PROLIFIC_PID %in% dat_zero$PROLIFIC_PID[tmp]] <- 1


## ADD by Mahalanobis distance (multivariate outliers)
table(rowSums(dat_MD[,labels]))
tmp <- rowSums(dat_MD[,labels]) >= 2
dat_IER$MD <- 0
dat_IER$MD[dat_IER$PROLIFIC_PID %in% dat_MD$PROLIFIC_PID[tmp]] <- 1
```

### IER: investigate

```{r}
sum(rowSums(dat_IER[,2:ncol(dat_IER)]) >= 2)
dat_IER[rowSums(dat_IER[,2:ncol(dat_IER)]) >= 2,]

## flag to delete
tmp_IDs <- dat_IER$PROLIFIC_PID[rowSums(dat_IER[,2:ncol(dat_IER)]) >= 2]
dat$flagDelete <- 0
dat$flagDelete[dat$PROLIFIC_PID %in% tmp_IDs] <- 1

 dat[dat$flagDelete == 1, str_subset(string = colnames(dat), pattern = "^EcologicalDimension")]
 dat[dat$flagDelete == 1, str_subset(string = colnames(dat), pattern = "^Bioinspiration.")]
```

> after visual inspection no removal of participants




# Evaluation Scales


## Overall EFA

Promax rotation, factoring method minimum residual, if scale is a likert scale less or equal than 7 answering options the EFA or parallel analysis is computed over a polychoric correlation to account for non-normality of data (see in detail R-Code “helperFunctions”)


```{r}
#### Overall EFA
regExOverall <- "^Bioinspiration|^EcologicalDimension"


psych::cor.plot(r = cor(dat[, str_detect(string = colnames(dat),
                                                   pattern = regExOverall)]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "Overall")

#> parallel analysis
tmp_parallelAnalysis <- dimensionalityTest(label = "Overall",
                             regEx = regExOverall, dataset = dat)


#> EFA (# of factors=2)
tmp_EFA <- explorativeFactorAnalysis(label = "Overall",
                                 regEx = regExOverall,
                                 dataset = dat, nfac = 2)
tmp_EFA[[1]]
```

> two factor structure, within bioinspiried dimensions no strong differences in overall answering patterns; 1 items is dysfunctional (negative correlated)


### EFA for "Bioinspiration Items"


```{r}
#### Overall EFA
regExOverall <- "^Bioinspiration"


psych::cor.plot(r = cor(dat[, str_detect(string = colnames(dat),
                                                   pattern = regExOverall)]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "Overall")

#> parallel analysis
tmp_parallelAnalysis <- dimensionalityTest(label = "Overall",
                             regEx = regExOverall, dataset = dat)


#> EFA (# of factors=5)
tmp_EFA <- explorativeFactorAnalysis(label = "Overall",
                                 regEx = regExOverall,
                                 dataset = dat, nfac = 2)
tmp_EFA[[1]]
```

## Descriptives, correlation plot, EFA, CFA for "Ecological Sustainability Scale (PES)"

Applied a self-written function for example to check the reliability and amount of explained variance for the first factor: 


```{r}
#| echo: true
#| warning: false

regEx <- "^EcologicalDimension"
nameVariable <- "Ecology"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)

des_tab <- tmp$desTable %>%
  as.data.frame() %>%
  select(Mean, SD, Skewness, `Kurtosis(-3)`, `KS-Test`)
stargazer(
  des_tab,
  summary = FALSE,
  rownames = TRUE,
  title = "Descriptive Statistics for Ecological Items",
  label = "tab:ecology_desc",
  digits = 2,
  table.placement = "ht!",
  font.size = "small"
)

omega_results <- psych::omega(tmp_dat, nfactors = 1)  # or more if needed
omega_results

omega_results$omega.tot    # Total Omega
omega_results$omega.h      # Hierarchical Omega
omega_results$omega.g      # Group Omega (if multiple factors)
```


## Descriptives, correlation plot, EFA, CFA for "Perceived Bio-Inspiration Scale (PBS)"

### overall 

```{r}
#| echo: true
#| warning: false

regEx <- "^Bioinspiration"
nameVariable <- "Bioinspiration"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)
```


### Visual Resemblance to Nature (VRtN)

```{r}
#| echo: true
#| warning: false

regEx <- "^Bioinspiration-VRtN"
nameVariable <- "VRtN"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)

des_tab <- tmp$desTable %>%
  as.data.frame() %>%
  select(Mean, SD, Skewness, `Kurtosis(-3)`, `KS-Test`)
stargazer(
  des_tab,
  summary = FALSE,
  rownames = TRUE,
  title = "Descriptive Statistics for Ecological Items",
  label = "tab:ecology_desc",
  digits = 2,
  table.placement = "ht!",
  font.size = "small"
)

omega_results <- psych::omega(tmp_dat, nfactors = 1)  # or more if needed
omega_results

omega_results$omega.tot    # Total Omega
omega_results$omega.h      # Hierarchical Omega
omega_results$omega.g      # Group Omega (if multiple factors)
```

### Intentionality & Perceived Inspiration (IPI)


```{r}
#| echo: true
#| warning: false

regEx <- "^Bioinspiration-IPI"
nameVariable <- "IPI"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)

des_tab <- tmp$desTable %>%
  as.data.frame() %>%
  select(Mean, SD, Skewness, `Kurtosis(-3)`, `KS-Test`)
stargazer(
  des_tab,
  summary = FALSE,
  rownames = TRUE,
  title = "Descriptive Statistics for Ecological Items",
  label = "tab:ecology_desc",
  digits = 2,
  table.placement = "ht!",
  font.size = "small"
)

omega_results <- psych::omega(tmp_dat, nfactors = 1)  # or more if needed
omega_results

omega_results$omega.tot    # Total Omega
omega_results$omega.h      # Hierarchical Omega
omega_results$omega.g      # Group Omega (if multiple factors)
```


### Perceived Naturalness (PN)


```{r}
#| echo: true
#| warning: false

regEx <- "^Bioinspiration-PN"
nameVariable <- "PN"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)
```


## Delete Items

```{r}
dat$`Bioinspiration-PN2r` <- NULL
```


### run again: Perceived Naturalness (PN)


```{r}
#| echo: true
#| warning: false

regEx <- "^Bioinspiration-PN"
nameVariable <- "PN"


sum(str_detect(string = colnames(dat), pattern = regEx))

tmp_dat <- na.omit(dat[,str_detect(string = colnames(dat), pattern = regEx)])


tmp <- CFAstats(dataset = tmp_dat, regularExp = regEx, labelLatent = str_remove(string = nameVariable, pattern = "mean_"), 
                showPlots = TRUE, 
                computeEFA = TRUE, 
                computeCFA = TRUE, 
                computeCFAMplus = FALSE)


des_tab <- tmp$desTable %>%
  as.data.frame() %>%
  select(Mean, SD, Skewness, `Kurtosis(-3)`, `KS-Test`)
stargazer(
  des_tab,
  summary = FALSE,
  rownames = TRUE,
  title = "Descriptive Statistics for Ecological Items",
  label = "tab:ecology_desc",
  digits = 2,
  table.placement = "ht!",
  font.size = "small"
)

omega_results <- psych::omega(tmp_dat, nfactors = 1)  # or more if needed
omega_results

omega_results$omega.tot    # Total Omega
omega_results$omega.h      # Hierarchical Omega
omega_results$omega.g      # Group Omega (if multiple factors)
```


### run again: EFA for “Bioinspiration Items”

```{r}
#### Overall EFA
regExOverall <- "^Bioinspiration"


psych::cor.plot(r = cor(dat[, str_detect(string = colnames(dat),
                                                   pattern = regExOverall)]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "Overall")

#> parallel analysis
tmp_parallelAnalysis <- dimensionalityTest(label = "Overall",
                             regEx = regExOverall, dataset = dat)


#> EFA (# of factors=5)
tmp_EFA <- explorativeFactorAnalysis(label = "Overall",
                                 regEx = regExOverall,
                                 dataset = dat, nfac = 2)
tmp_EFA[[1]]
```

## Item Response Theory (polytomous) for "Bioinspiration Items"


Factor Loadings (F1) indicate how strongly each item is associated with the latent trait, rule of thumb:

+ 0.70 = strong
+ 0.40–0.69 = moderate
+ < 0.40 = weak
    
Communality (h²) is the proportion of variance in each item explained by the factor, rule of thumb:
+ h² > 0.40 → item is well represented
+ h² < 0.30 → potentially problematic item

```{r}
if(runIRTmodels){
  # Choose dataset and regular expression
  regEx <- "^Bioinspiration"
  
  # Filter variables matching the pattern
  irt_items <- dat[, str_detect(colnames(dat), pattern = regEx)]
  
  # Drop rows with missing data (mirt requires complete cases)
  irt_items <- na.omit(irt_items)
  
  # Ensure all items are treated as ordered factors
  irt_items[] <- lapply(irt_items, function(x) as.numeric(as.character(x)))
  # Fit Graded Response Model (1-factor)
  mod_grm <- mirt(data = irt_items, model = 1, itemtype = "graded", verbose = FALSE)
  
  # Summarize model
  summary(mod_grm)
  
  
  # Plot Item Characteristic Curves (ICCs) for all items
  plot(mod_grm, type = "trace", facet_items = TRUE, main = "Item Characteristic Curves")
  
  # Plot Test Information Curve
  plot(mod_grm, type = "info", main = "Test Information Curve: Bioinspiration")
  
  
  
  ### compare results to:
  cor.plot(r = cor(irt_items))
}
```



Compare 1-Factor vs. 2-Factor Models:

```{r}
if(runIRTmodels){
  mod_1f <- mirt(data = irt_items, model = 1, itemtype = "graded", verbose = FALSE)
  mod_2f <- mirt(data = irt_items, model = 2, itemtype = "graded", verbose = FALSE)
  mod_3f <- mirt(data = irt_items, model = 3, itemtype = "graded", verbose = FALSE)
  anova(mod_1f, mod_2f, mod_3f)
  
  summary(mod_2f)
summary(mod_3f)
}
```

> significant p-value (e.g., < .05) supports the 2-factor model.



# Compute mean scores

```{r}
dat$mean_Bioinspiration <- rowMeans(x = dat[,str_subset(colnames(dat), pattern = "^Bioinspiration")])
dat$mean_Bioinspiration_PN <- rowMeans(x = dat[,str_subset(colnames(dat), pattern = "^Bioinspiration-PN")])
dat$mean_Bioinspiration_IPI <- rowMeans(x = dat[,str_subset(colnames(dat), pattern = "^Bioinspiration-IPI")])
dat$mean_Bioinspiration_VRtN <- rowMeans(x = dat[,str_subset(colnames(dat), pattern = "^Bioinspiration-VRtN")])

dat$mean_Ecological <- rowMeans(x = dat[,str_subset(colnames(dat), pattern = "^EcologicalDimension")])
```

manifest correlations:

```{r}
psych::cor.plot(r = cor(dat[, str_detect(string = colnames(dat),
                                                   pattern = "^mean_")]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "Overall")
```

```{r}
psych::cor.plot(r = cor(dat[dat$framingCondition == "bioinspired", str_detect(string = colnames(dat),
                                                   pattern = "^mean_")]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "For subset bioinspired")


plot(dat[dat$framingCondition == "bioinspired", "mean_Ecological"], dat[dat$framingCondition == "bioinspired", "mean_Bioinspiration_IPI"]) # PN most strongly related to sustainability
plot(dat[dat$framingCondition == "bioinspired", "mean_Ecological"], dat[dat$framingCondition == "bioinspired", "mean_Bioinspiration_PN"])


psych::cor.plot(r = cor(dat[dat$framingCondition == "neutral", str_detect(string = colnames(dat),
                                                   pattern = "^mean_")]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "For subset neutral")

psych::cor.plot(r = cor(dat[dat$framingCondition == "sustainable", str_detect(string = colnames(dat),
                                                   pattern = "^mean_")]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "For subset sustainable")
```

```{r}
dat %>% 
  group_by(framingCondition) %>%
  dplyr::summarise(
    N = n(),
    mean_Eco = mean(mean_Ecological, na.rm = TRUE),
    sd_Eco   = sd(mean_Ecological, na.rm = TRUE),
    
    mean_BioOverall = mean(mean_Bioinspiration, na.rm = TRUE),
    sd_BioOverall   = sd(mean_Bioinspiration, na.rm = TRUE),
    
    mean_Bio_PN = mean(mean_Bioinspiration_PN, na.rm = TRUE),
    sd_Bio_PN   = sd(mean_Bioinspiration_PN, na.rm = TRUE),
    
    mean_Bio_IPI = mean(mean_Bioinspiration_IPI, na.rm = TRUE),
    sd_Bio_IPI   = sd(mean_Bioinspiration_IPI, na.rm = TRUE),
    
    mean_Bio_VRtN = mean(mean_Bioinspiration_VRtN, na.rm = TRUE),
    sd_Bio_VRtN   = sd(mean_Bioinspiration_VRtN, na.rm = TRUE)
  )
```


# Test Hypotheses

## Descriptive

```{r}
# Summaries of participant-level scores by framing condition
eco_summary <- data_summary(dat, "mean_Ecological", "framingCondition")
bio_summary <- data_summary(dat, "mean_Bioinspiration", "framingCondition")

# View results
print(eco_summary)
print(bio_summary)
```


```{r}
# Plots the mean scores on the Bioinspiration & Ecological Dimension by Framing Condition
ggplot(dat, aes(x = framingCondition, y = mean_Ecological)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Ecological Dimension by Framing", y = "Mean Score") +
  theme_minimal()

ggplot(dat, aes(x = framingCondition, y = mean_Bioinspiration)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Bioinspiration by Framing", y = "Mean Score") +
  theme_minimal()
```

## ANOVAs

ANOVAs + post hoc tests:

```{r}
#| message: false
#| warning: false


# --- ANOVA for Bioinspiration ---
aov_bio <- aov_ez(
  id = "PROLIFIC_PID",  # replace with your participant ID column name
  dv = "mean_Bioinspiration",
  data = dat,
  between = "framingCondition"
)
print(aov_bio)

# Post hoc (Tukey) for Bioinspiration
em_bio <- emmeans(aov_bio, "framingCondition")
bio_posthoc <- pairs(em_bio, adjust = "tukey")
print(bio_posthoc)

# --- ANOVA for Ecological Dimension ---
aov_eco <- aov_ez(
  id = "PROLIFIC_PID",  # replace with your participant ID column name
  dv = "mean_Ecological",
  data = dat,
  between = "framingCondition"
)
print(aov_eco)

# Post hoc (Tukey) for Ecological
em_eco <- emmeans(aov_eco, "framingCondition")
eco_posthoc <- pairs(em_eco, adjust = "tukey")
print(eco_posthoc)
```

plots in APA7 style:

```{r}
#| message: false
#| warning: false

# Summarize means and SE for plotting
bio_plot_data <- data_summary(dat, "mean_Bioinspiration", "framingCondition")
eco_plot_data <- data_summary(dat, "mean_Ecological", "framingCondition")

# --- Bioinspiration Plot ---
ggplot(bio_plot_data, aes(x = framingCondition, y = mean_Bioinspiration)) +
  geom_col(fill = "grey80", color = "black", width = 0.6) +
  geom_errorbar(aes(ymin = mean_Bioinspiration - se, ymax = mean_Bioinspiration + se), width = 0.15) +
  labs(x = "Framing Condition", y = "Mean Bioinspiration Score") +
  theme_apa() +
  theme(
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )

# --- Ecological Dimension Plot ---
ggplot(eco_plot_data, aes(x = framingCondition, y = mean_Ecological)) +
  geom_col(fill = "grey60", color = "black", width = 0.6) +
  geom_errorbar(aes(ymin = mean_Ecological - se, ymax = mean_Ecological + se), width = 0.15) +
  labs(x = "Framing Condition", y = "Mean Ecological Score") +
  theme_apa() +
  theme(
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )
```

## Spillover

We are comparing the effect size or magnitude of:

- How much "bioinspired" framing boosts sustainability ratings.
- How much "sustainable" framing boosts bioinspiration ratings.


```{r}
# Subset only relevant cases and variables
dat_subset <- dat %>%
  # filter(framingCondition %in% c("bioinspired", "sustainable")) %>%
  select(PROLIFIC_PID, framingCondition, mean_Bioinspiration, mean_Ecological)

# Standardize the two scales
dat_subset <- dat_subset %>%
  mutate(
    z_Bioinspiration = scale(mean_Bioinspiration)[, 1],
    z_Sustainability = scale(mean_Ecological)[, 1]
  )


# Convert to long format
dat_long_scaled <- dat_subset %>%
  pivot_longer(cols = c(z_Bioinspiration, z_Sustainability),
               names_to = "ratingType",
               values_to = "ratingScore") %>%
  mutate(
    ratingType = dplyr::recode(ratingType,
                        "z_Bioinspiration" = "Bioinspiration",
                        "z_Sustainability" = "Sustainability"),
    framingCondition = factor(framingCondition),
    ratingType = factor(ratingType)
  )

dat_long_scaled$ratingType <- as.factor(dat_long_scaled$ratingType)
dat_long_scaled$framingCondition <- relevel(dat_long_scaled$framingCondition, ref = "neutral")
```

The interaction term now reflects difference in effect sizes in standard deviation units (comparable spillover strength):

```{r}
levels(dat_long_scaled$framingCondition)
levels(dat_long_scaled$ratingType)


# Run interaction model
model_scaled <- lm(ratingScore ~ framingCondition * ratingType, data = dat_long_scaled)
summary(model_scaled)


stargazer(model_scaled)
```
no differences in mean scores between groups, only changes in variance:

```{r}
library(lme4)
library(lmerTest)
library(performance)


model_mixed <- lmer(
  ratingScore ~ framingCondition * ratingType +
    (1 | PROLIFIC_PID),
  data = dat_long_scaled
)

icc(model_mixed)

summary(model_mixed)
```





```{r}
dat_long_scaled %>%
  group_by(framingCondition, ratingType) %>%
  dplyr::summarise(
    N = n(),
    mean_DV = mean(ratingScore, na.rm = TRUE)
  )
```



```{r}
ggplot(dat_long_scaled, aes(x = framingCondition, y = ratingScore, fill = ratingType)) +
    scale_fill_manual(
    values = c("Bioinspiration" = "#A67C49", "Sustainability" = "#55A868")
  ) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.7), width = 0.6, color = "black") +
  stat_summary(fun.data = mean_se, geom = "errorbar", 
               position = position_dodge(0.7), width = 0.15) +
  labs(x = "Framing Condition", y = "Rating Score", fill = "Rating Type") +
  theme_minimal()

ggplot(dat_long_scaled, aes(x = ratingType, y = ratingScore, fill = framingCondition)) +
    scale_fill_manual(
    values = c("bioinspired" = "#A67C49", "sustainable" = "#55A868", "neutral" = "#E8D28B")
  ) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.7), width = 0.6, color = "black") +
  stat_summary(fun.data = mean_se, geom = "errorbar", 
               position = position_dodge(0.7), width = 0.15) +
  labs(x = "Framing Condition", y = "Rating Score", fill = "Rating Type") +
  theme_minimal()
```





```{r}
# Reshape from wide to long format
dat_long <- dat_subset %>%
  pivot_longer(cols = c(mean_Bioinspiration, mean_Ecological),
               names_to = "ratingType",
               values_to = "ratingScore") %>%
  mutate(
    ratingType = dplyr::recode(ratingType,
                        "mean_Bioinspiration" = "Bioinspiration",
                        "mean_Ecological" = "Sustainability"),
    framingCondition = as.factor(framingCondition),
    ratingType = as.factor(ratingType)
  )


ggplot(dat_long, aes(x = framingCondition, y = ratingScore, fill = ratingType)) +
  stat_summary(
    fun = mean, geom = "col", position = position_dodge(0.75), 
    width = 0.6, color = "black"
  ) +
  stat_summary(
    fun.data = mean_se, geom = "errorbar", 
    position = position_dodge(0.75), width = 0.2, size = 0.8
  ) +
  scale_fill_manual(
    values = c("Bioinspiration" = "#A67C49", "Sustainability" = "#55A868")
  ) +
  labs(
    x = "Framing Condition",
    y = "Mean Rating Score",
    fill = "Rating Type",
    title = "Effect of Framing on Bioinspiration and Sustainability Ratings"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.position = "top",
    legend.title = element_text(face = "bold"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )


ggplot(dat_long, aes(x = ratingType, y = ratingScore, fill = framingCondition)) +
  stat_summary(
    fun = mean, geom = "col", position = position_dodge(0.75), 
    width = 0.6, color = "black"
  ) +
  stat_summary(
    fun.data = mean_se, geom = "errorbar", 
    position = position_dodge(0.75), width = 0.2, size = 0.8
  ) +
  scale_fill_manual(
    values = c("bioinspired" = "#A67C49", "sustainable" = "#55A868", "neutral" = "#E8D28B")
  ) +
  labs(
    x = "Rating Type",
    y = "Mean Rating Score",
    fill = "Framing Condition",
    title = "Effect of Framing on Bioinspiration and Sustainability Ratings"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.position = "top",
    legend.title = element_text(face = "bold"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )
```


```{r}
# Estimated marginal means for each cell
emm <- emmeans(model_scaled, ~ framingCondition * ratingType)
emm

# Simple effects of ratingType within each level of framingCondition
simple_rating_by_frame <- contrast(
  emm,
  method = "pairwise",
  by = "framingCondition",
  adjust = "none"   # or "bonferroni", "holm", etc. if you like
)

summary(simple_rating_by_frame)


# Simple effects of framingCondition within each level of ratingType
simple_frame_by_rating <- contrast(
  emm,
  method = "pairwise",
  by = "ratingType",
  adjust = "none"
)

summary(simple_frame_by_rating)


all_contrasts <- contrast(emm, method = "pairwise", adjust = "none")
summary(all_contrasts)


plot(emm, comparisons = TRUE, by = "framingCondition")
plot(emm, comparisons = TRUE, by = "ratingType")
```
## investigate if order of scales shown has an influence (in neutral)

```{r}
table(dat$framingCondition, dat$whichItemsFirst)
```


```{r}
dat <- dat %>%
  mutate(framingCondition_neutral = case_when(
    framingCondition == "bioinspired" & whichItemsFirst == "bioinspired" ~ "bioinspired",
    framingCondition == "sustainable" & whichItemsFirst == "sustainable" ~ "sustainable",
    framingCondition == "neutral" & whichItemsFirst == "sustainable" ~ "neut_sustainable",
    framingCondition == "neutral" & whichItemsFirst == "bioinspired" ~ "neut_bioinspired"
  ))

table(dat$framingCondition_neutral)
```

```{r}
ggplot(dat, aes(x = framingCondition_neutral, y = mean_Bioinspiration)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Bioinspiration by Framing", y = "Mean Score") +
  theme_minimal()


ggplot(dat, aes(x = framingCondition_neutral, y = mean_Bioinspiration_PN)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Bioinspiration by Framing", y = "Mean Score PN") +
  theme_minimal()

ggplot(dat, aes(x = framingCondition_neutral, y = mean_Bioinspiration_IPI)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Bioinspiration by Framing", y = "Mean Score IPI") +
  theme_minimal()

ggplot(dat, aes(x = framingCondition_neutral, y = mean_Bioinspiration_VRtN)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Bioinspiration by Framing", y = "Mean Score VRtN") +
  theme_minimal()
```

```{r}
ggplot(dat, aes(x = framingCondition_neutral, y = mean_Ecological)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Ecological Dimension by Framing", y = "Mean Score") +
  theme_minimal()
```

ANOVAs + post hoc tests:

```{r}
#| message: false
#| warning: false


# --- ANOVA for Bioinspiration ---
aov_bio <- aov_ez(
  id = "PROLIFIC_PID",  # replace with your participant ID column name
  dv = "mean_Bioinspiration",
  data = dat,
  between = "framingCondition_neutral"
)
print(aov_bio)

# Post hoc (Tukey) for Bioinspiration
em_bio <- emmeans(aov_bio, "framingCondition_neutral")
bio_posthoc <- pairs(em_bio, adjust = "tukey")
print(bio_posthoc)

# --- ANOVA for Ecological Dimension ---
aov_eco <- aov_ez(
  id = "PROLIFIC_PID",  # replace with your participant ID column name
  dv = "mean_Ecological",
  data = dat,
  between = "framingCondition_neutral"
)
print(aov_eco)

# Post hoc (Tukey) for Ecological
em_eco <- emmeans(aov_eco, "framingCondition_neutral")
eco_posthoc <- pairs(em_eco, adjust = "tukey")
print(eco_posthoc)
```




# Heterogeneity

## latent class analysis for mean items



manifest correlations:

```{r}
psych::cor.plot(r = cor(dat[, str_detect(string = colnames(dat),
                                                   pattern = "^mean_")]
                        , use = "pairwise.complete.obs"),
                upper = FALSE, xlas = 2, main = "Overall")
```

```{r}
hist(dat$mean_Bioinspiration)

hist(dat$mean_Bioinspiration_PN)
hist(dat$mean_Bioinspiration_IPI)
hist(dat$mean_Bioinspiration_VRtN)

hist(dat$mean_Ecological)
```



```{r}
colnames(dat)
nrow(dat)
length(unique(dat$ID))
length(unique(dat$PROLIFIC_PID))
```




```{r}
setwd("outputs/LCA_means")


if(runMplusLCA){
  

  LCA_dat <- dat[, c("ID", "mean_Ecological", "mean_Bioinspiration_PN", "mean_Bioinspiration_IPI", "mean_Bioinspiration_VRtN")]
  

  tmp <- str_subset(string = colnames(LCA_dat), pattern = "^mean_")
  tmp <- str_remove_all(string = tmp, pattern = "^mean_")
    tmp <- str_remove_all(string = tmp, pattern = "inspiration|logical")

  # cat(paste0(tmp, "(", 1:length(tmp), ")"))
  # cat(paste0(tmp))


  colnames(LCA_dat) <- c("ID", tmp)


  # prepareMplusData(df = LCA_dat, filename = "LCA_dat.dat")


  l = 1
  list_lca_means <- list()
  for(i in 2:LCArunsDef){
    print(i)

    numClasses <- i

    LCA_mplus  <- mplusObject(

      TITLE = paste0("Latent Class Analysis Mean Scales", " c=", numClasses),

      VARIABLE =paste0("
  usevariables = Eco Bio_PN Bio_IPI Bio_VRtN;

  classes      = c(", numClasses, ")"),

  ANALYSIS =
    "
    Type=mixture; ! LCA analysis
    STARTS= 500 100;
    !LRTstarts=0 0 300 20;
  ",

  PLOT =
    "
    type = plot3;
    series is Eco(1) Bio_PN(2) Bio_IPI(3) Bio_VRtN(4);
  ",

  SAVEDATA = paste0("file = lca_", numClasses, ".txt ;
    save = cprob;
    format = free;
  "),

  OUTPUT = "tech11 tech14;", rdata = LCA_dat)

    list_lca_means[[l]] <- mplusModeler(LCA_mplus,
                                         modelout = paste0("lca_means", numClasses, ".inp"),
                                         run = 1L)

    l = l + 1
  }

  # comment out to avoid overwriting LCA outputs
  saveRDS(list_lca_means, file="list_lca_means.rds")

}else{
  list_lca_means <- readRDS("list_lca_means.rds" )
}
```


```{r}
getLCAfitstatistics(listMplusOutput = list_lca_means)
```



```{r}
### number of classes
num_classes <- 3 # index - 1

# Step 1: Extract means
params <- list_lca_means[[num_classes]]$results$parameters$unstandardized

means_df <- params %>%
  filter(paramHeader == "Means" & !grepl("^C#\\d$", param))

# Step 2: Get class proportions
class_counts <- table(list_lca_means[[num_classes]]$results$savedata$C)
total_n <- sum(class_counts)
class_props <- round(100 * class_counts / total_n, 1)

# Create descriptive labels
class_labels <- paste0("Class ", names(class_counts), " (", class_props, "%)")

# Map class numbers to labels
class_label_map <- setNames(class_labels, paste0("Class ", names(class_counts)))

# Step 3: Prepare data for plotting
means_long <- means_df %>%
  mutate(Indicator = param,
         Class = paste0("Class ", LatentClass)) %>%
  select(Indicator, Class, est) %>%
  pivot_wider(names_from = Class, values_from = est) %>%
  pivot_longer(cols = starts_with("Class"), names_to = "Class", values_to = "Mean")

# Apply the new labels
means_long$Class <- class_label_map[means_long$Class]

# Optional: Set indicator order
means_long$Indicator <- factor(means_long$Indicator)
# means_long$Indicator <- factor(means_long$Indicator,
#                                 levels = c("Eco", "Bio_PN", "Bio_IPI", "Bio_VRtN"))
   
# Step 4: Plot
ggplot(means_long, aes(x = Indicator, y = Mean, group = Class, color = Class)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(title = "Latent Class Profile Plot",
       x = "Items",
       y = "Estimated Means") +
  theme(text = element_text(size = 14),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.title = element_blank())
```
```{r}
class_counts
class_counts / nrow(dat)
```

> we chose the 4 class solution as the best model


```{r}
setwd("outputs/LCA_means")


dat_classes <- read.table(file = "lca_4_choosen.txt")
dat$lclasses_BioEco <- dat_classes$V9
```
```{r}
classes_tables <- table(dat$lclasses_BioEco, dat$framingCondition)
classes_tables

chi <- chisq.test(classes_tables, correct = FALSE)
chi_stat <- chi$statistic
chi

# Cramer's V
n <- sum(classes_tables)
k <- min(nrow(classes_tables), ncol(classes_tables))

cramers_v <- sqrt(chi_stat / (n * (k - 1)))
cramers_v
```

```{r}
# Extract standardized residuals
std_res <- chi$stdres
round(std_res, 2)  # rounded for readability

# See which cells are "large" (e.g., |residual| > 2)
which(abs(std_res) > 2, arr.ind = TRUE)

# A heatmap of standardized residuals with ggplot2

res_df <- as.data.frame(as.table(std_res))
colnames(res_df) <- c("lclasses_BioEco", "framingCondition", "stdres")

ggplot(res_df, aes(x = framingCondition,
                   y = lclasses_BioEco,
                   fill = stdres)) +
  geom_tile() +
  geom_text(aes(label = round(stdres, 2))) +
  scale_fill_gradient2(
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0
  ) +
  labs(
    title = "Standardized residuals: lclasses_BioEco × framingCondition",
    x = "Framing condition",
    y = "lclasses_BioEco",
    fill = "Std. resid"
  ) +
  theme_minimal()
```

